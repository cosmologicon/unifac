// A path along hexes that sprites follow

// Lanespec has the following members:

// branches: an array of arrays. Each array is filled with pH values, as generated by the
// spacelane-draw tool.

// A segment is a path an attacker follows within a given hex. A tile consists of one or more
// entry points and one or more exit points along a tile, and corresponds to one or more segments.
// In particular, a branching tile consists of two segments and one tile.

// Segments are used for determining how attackers move. Tiles are used for drawing.

// For edge numbering conventions, please see notes dated 24 Feb 2014.

function Spacelane(spec) {
	if (!(this instanceof Spacelane)) return new Spacelane(spec)
	this.init(spec)
}
Spacelane.prototype = {
	init: function (spec) {
		this.spec = spec
		var bstartNs = {}, bendNs = {}  // pN -> branches that start or end here
		spec.branches.forEach(function (branch, jbranch) {
			var bstartN = NconvertH(branch[0]), bendN = NconvertH(branch[branch.length - 1])
			bstartNs[bstartN] = (bstartNs[bstartN] || []).concat([jbranch])
			bendNs[bendN] = (bendNs[bendN] || []).concat([jbranch])
		})
		var nfeeders = spec.branches.map(function (branch) {
			var b = bendNs[NconvertH(branch[0])]
			return b ? b.length : 0
		})
		var neaters = spec.branches.map(function (branch) {
			var b = bstartNs[NconvertH(branch[branch.length - 1])]
			return b ? b.length : 0
		})
		
		var nsegments = []  // number of segments within each branch
		var jsegment0 = [0]  // first segment of each branch
		spec.branches.forEach(function (branch, jbranch) {
			var bendN = NconvertH(branch[branch.length - 1])
			// bracnhes that feed into another branch have N-1 segments, otherwise N segments
			var n = branch.length - (nfeeders[jbranch] > 1 ? 1 : 0) - (neaters[jbranch] > 1 ? 1 : 0)
			nsegments.push(n)
			jsegment0.push(jsegment0[jbranch] + n)
		})

		var segments = this.segments = []
		var startsegments = this.startsegments = []
		var LGs = [0, tau/6, tau/4, Math.sqrt(3), tau/4, tau/6]
		var rotCs = [1, 0.5, -0.5, -1, -0.5, 0.5]
		var rotSs = [0, s3, s3, 0, -s3, -s3]
		var tilespec = {}
		spec.branches.forEach(function (branch, jbranch) {
			var iedges = [], jedges = [], iedge, oedge
			// The first segment in the branch
			if (nfeeders[jbranch] == 0) {  // Starting branch, has a straight entrance
				iedges.push(edgebetweenH(branch[1], branch[0]))
				jedges.push(3)
				startsegments.push(segments.length)
			} else if (nfeeders[jbranch] == 1) {  // Single feeder, look at last segment of previous branch
				var feeder = spec.branches[bendNs[NconvertH(branch[0])][0]]
				iedge = edgebetweenH(branch[0], feeder[feeder.length - 2])
				iedges.push(iedge)
				oedge = edgebetweenH(branch[0], branch[1])
				jedges.push((oedge - iedge + 6) % 6)
			} else {  // Multiple feeders, no first segment
				iedges.push(null)
				jedges.push(0)
			}
			// Middle segments of the branch
			for (var jp = 1 ; jp < branch.length - 1 ; ++jp) {
				iedge = edgebetweenH(branch[jp], branch[jp-1])
				oedge = edgebetweenH(branch[jp], branch[jp+1])
				iedges.push(iedge)
				jedges.push((oedge - iedge + 6) % 6)
			}
			// Final segment of the branch
			if (neaters[jbranch] == 0) {  // Terminal branch, has a straight entrance
				iedges.push(edgebetweenH(branch[branch.length - 1], branch[branch.length - 2]))
				jedges.push(3)
			} else if (neaters[jbranch] == 1) {  // Single eater, look at first segment of next branch
				var eater = spec.branches[bstartNs[NconvertH(branch[branch.length - 1])][0]]
				iedge = edgebetweenH(branch[branch.length - 1], branch[branch.length - 2])
				iedges.push(iedge)
				oedge = edgebetweenH(eater[0], eater[1])
				jedges.push((oedge - iedge + 6) % 6)
			} else {  // Multiple eaters, no final segment
				iedges.push(null)
				jedges.push(0)
			}
			
			var nextjsegs = null
			if (neaters[jbranch]) {
				nextjsegs = bstartNs[NconvertH(branch[branch.length - 1])].map(function (jbranch) {
					return jsegment0[jbranch]
				})
			}

			branch.forEach(function (pH, jp) {
				var pG = GconvertH(pH), iedge = iedges[jp], jedge = jedges[jp]
				if (jedge == 0) return
				segments.push({
					pH: pH,
					pG: pG,
					jedge: jedge,
					rotC: rotCs[iedge],
					rotS: rotSs[iedge],
					LG: LGs[jedge],
					nextjsegs: [segments.length + 1],
				})
				var pN = NconvertH(pH)
				;(tilespec[pN] = tilespec[pN] || []).push([iedge, jedge])
			})
			segments[segments.length - 1].nextjsegs = nextjsegs
		})
		
		
		this.tiles = []
		for (var pN in tilespec) {
			var edges = tilespec[pN]
			var pH = HconvertN(pN), pG = GconvertH(pH)
			var iedge = edges[0][0], shape
			if (bstartNs[pN] && !bendNs[pN]) {
				shape = "enter"
			} else if (!bstartNs[pN] && bendNs[pN]) {
				shape = "exit"
			} else {
				var shape = "tile"
				for (var j = 0 ; j < edges.length ; ++j) {
					shape += (edges[j][0] - iedge + 6) % 6
					shape += (edges[j][0] + edges[j][1] - iedge + 6) % 6
				}
			}
			this.tiles.push({
				pG: pG,
				rotC: rotCs[iedge],
				rotS: rotSs[iedge],
				shape: shape,
			})
		}
	},
	claimspace: function (objsbyedgeN, objsbyhexN) {
		var lane = this
		this.spec.branches.forEach(function (branch) {
			branch.forEach(function (pH, j) {
				objsbyhexN[NconvertH(pH)] = lane
				if (!j) return
				var edgepH = [(pH[0]+branch[j-1][0])/2, (pH[1]+branch[j-1][1])/2]
				objsbyedgeN[NconvertH(edgepH)] = lane
			})
		})
	},
	place: function (obj, d) {
		obj.dsegment = 0
		obj.jsegment = UFX.random.choice(this.startsegments)
		this.advance(obj, d || 0)
	},
	advance: function (obj, dd) {
		obj.dsegment += dd
		while (obj.dsegment > this.segments[obj.jsegment].LG) {
			obj.dsegment -= this.segments[obj.jsegment].LG
			var nextjsegs = this.segments[obj.jsegment].nextjsegs || this.startsegments
			obj.jsegment = nextjsegs.length == 1 ? nextjsegs[0] : UFX.random.choice(nextjsegs)
		}
		this.setpos(obj)
	},
	setpos: function (obj) {
		var segment = this.segments[obj.jsegment], d = obj.dsegment, x, y, dx, dy
		if (segment.jedge == 3) {
			x = 0 ; y = -s3 + d ; dx = 0 ; dy = 1
		} else {
			var r = segment.jedge == 1 || segment.jedge == 5 ? 0.5 : 1.5
			var theta = d / r, C = Math.cos(theta), S = Math.sin(theta)
			var xflip = segment.jedge < 3 ? 1 : -1
			x = xflip * r * (1 - C)
			y = -s3 + r * S
			dx = xflip * S
			dy = C
		}
		obj.pG = [
			segment.pG[0] + x * segment.rotC - y * segment.rotS,
			segment.pG[1] + x * segment.rotS + y * segment.rotC,
		]
		obj.rotC = dy * segment.rotC + dx * segment.rotS
		obj.rotS = dx * segment.rotC - dy * segment.rotS
	},
}

var lanescape = {
	init: function () {
		this.scapesize = 512
		
		this.spotinfo = {}
		this.scale = 64
		this.blocksize = 2 * this.scale
		this.nblock = this.scapesize / this.blocksize
		this.jblock = 0

		gl.activeTexture(gl.TEXTURE0 + 2)
		this.texture = gl.createTexture()
		gl.bindTexture(gl.TEXTURE_2D, this.texture)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.scapesize, this.scapesize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
		gl.generateMipmap(gl.TEXTURE_2D)
		gl.bindTexture(gl.TEXTURE_2D, null)

		this.dbuffer = gl.createRenderbuffer()
		gl.bindRenderbuffer(gl.RENDERBUFFER, this.dbuffer)
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.scapesize, this.scapesize)

		this.fbo = gl.createFramebuffer()
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo)
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0)
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.dbuffer)
		if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) throw "Incomple color framebuffer"
		gl.clearColor(0, 0.5, 0.5, 0)
		gl.clear(gl.COLOR_BUFFER_BIT)
		gl.clear(gl.DEPTH_BUFFER_BIT)
		gl.bindFramebuffer(gl.FRAMEBUFFER, null)

		gl.activeTexture(gl.TEXTURE0)
	},

	setup: function () {
		graphics.progs.lanerender.use()
		gl.activeTexture(gl.TEXTURE0 + 2)
		gl.bindTexture(gl.TEXTURE_2D, this.texture)
		gl.enable(gl.BLEND)
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
		graphics.progs.lanerender.setsampler(2)
		var vs = state.viewstate
		graphics.progs.lanerender.setcanvassizeD(playpanel.wD, playpanel.hD)
		graphics.progs.lanerender.setvcenterG(vs.x0G, vs.y0G)
		graphics.progs.lanerender.setVscaleG(vs.VzoomG)
		graphics.progs.lanerender.setscapesizeD(this.scapesize)
		graphics.progs.lanerender.setbordercolor(0, 0.3, 0.8)
		graphics.progs.lanerender.setalpha(0.4 + 0.05 * Math.sin(0.002 * Date.now()))
		var mu = Date.now() * 0.005 % tau
		graphics.progs.lanerender.setcosmu(Math.cos(mu))
		graphics.progs.lanerender.setsinmu(Math.sin(mu))
		graphics.progs.lanerender.setClimit(0.4)
		gl.enableVertexAttribArray(graphics.progs.lanerender.attribs.posG)
		gl.bindBuffer(gl.ARRAY_BUFFER, graphics.unithexbuffer)
		gl.vertexAttribPointer(graphics.progs.lanerender.attribs.posG, 2, gl.FLOAT, false, 0, 0)
	},

	completeassembly: function (shape, spotinfo) {
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo)
		gl.viewport(spotinfo.x0, spotinfo.y0, this.blocksize, this.blocksize)
		gl.enable(gl.SCISSOR_TEST)
		gl.disable(gl.DEPTH_TEST)
		gl.disable(gl.BLEND)
		gl.scissor(spotinfo.x0, spotinfo.y0, this.blocksize, this.blocksize)
		graphics.progs.lane.use()
		graphics.progs.lane.setcanvassize(2, 2)
		graphics.progs.lane.setcenter(0, 0)
		graphics.progs.lane.setzoom(1)
		graphics.progs.lane.setlanewidth(0.4)
		graphics.progs.lane.setborderwidth(0.14)
		graphics.progs.lane.setalpha0(shape == "enter" ? -1 : 1)
		graphics.progs.lane.setalpha1(shape == "exit" ? -1 : 1)
		var anchors = shape.indexOf("tile") == 0 ? shape.substr(4) : "03"
		// Path variables: origin p, curvature k, path length L, indicator cycle count n
		// See lane.frag for more explanation of the variables.
		// For notes on the values here, see notebook dated 26 Jul 2014.
		var ps = [0, 0, 0, 0], ks = [0, 0], Ls = [0, 0], ns = [0, 0]
		for (var j = 0, i = 0 ; j < anchors.length ; j += 2, ++i) {
			var iedge = +anchors[j], oedge = +anchors[j+1], jedge = (oedge - iedge + 6) % 6
			ps[2*i] = [0, 0.75, 0.75, 0, -0.75, -0.75][iedge]
			ps[2*i+1] = [-s3, -0.5*s3, 0.5*s3, s3, 0.5*s3, -0.5*s3][iedge]
			ks[i] = [0, 2, 2/3, 0, -2/3, -2][jedge]
			Ls[i] = [0, tau/6, tau/4, s3*2, tau/4, tau/6][jedge]
			ns[i] = [0, 2, 3, 3, 3, 2][jedge]
		}
		graphics.progs.lane.vsetps(ps)
		graphics.progs.lane.vsetks(ks)
		graphics.progs.lane.vsetLs(Ls)
		graphics.progs.lane.vsetns(ns)
		graphics.drawunitsquare(graphics.progs.lane.attribs.pos)
		gl.disable(gl.SCISSOR_TEST)
		gl.bindFramebuffer(gl.FRAMEBUFFER, null)
		gl.activeTexture(gl.TEXTURE0 + 2)
		gl.bindTexture(gl.TEXTURE_2D, this.texture)
		gl.generateMipmap(gl.TEXTURE_2D)
	},
	
	getspotinfo: function (shape) {
		if (shape in this.spotinfo) return this.spotinfo[shape]
		var jblock = this.jblock++, xblock = jblock % this.nblock, yblock = Math.floor(jblock / this.nblock)
		var spotinfo = this.spotinfo[shape] = {
			shape: shape,
			x0: xblock * this.blocksize,
			y0: yblock * this.blocksize,
			cx: (xblock + 0.5) * this.blocksize,
			cy: (yblock + 0.5) * this.blocksize,
			scale: this.scale,
		}
		this.completeassembly(shape, spotinfo)
		this.setup()
		return spotinfo
	},
	
	drawtiles: function (tiles) {
		for (var j = 0 ; j < tiles.length ; ++j) {
			var tile = tiles[j], spotinfo = this.getspotinfo(tile.shape)
			graphics.progs.lanerender.setposD0(spotinfo.cx, spotinfo.cy)
			graphics.progs.lanerender.setDscaleG(spotinfo.scale)
			graphics.progs.lanerender.setscenterG(tile.pG[0], tile.pG[1])
			graphics.progs.lanerender.setrotC(tile.rotC)
			graphics.progs.lanerender.setrotS(tile.rotS)
			gl.drawArrays(gl.TRIANGLE_FAN, 0, 8)
		}
	},

}




